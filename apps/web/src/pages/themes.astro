---
import { getCollection } from "astro:content";
import cssSource from "@bejamas/ui/styles/globals.css?raw";
import { defaultPresets } from "../utils/themes/presets";
import { Label } from "@bejamas/ui/components/label";
import { Button } from "@bejamas/ui/components/button";
import { ArrowLeft, ArrowRight, CodeXml } from "@lucide/astro";
import StarlightPage from "@astrojs/starlight/components/StarlightPage.astro";
import PresetSwitcher from "../components/PresetSwitcher.astro";

const docs = await getCollection("docs");
const components = docs.filter((doc) => doc.id.startsWith("components/"));

const isTextToken = (token: string) =>
  token === "foreground" || token.endsWith("-foreground");

// Load CSS variables from the UI package at build-time (via Vite raw import)

function extractThemeBlock(css: string) {
  const match = css.match(/@theme\s*\{([\s\S]*?)\}/);
  return match ? match[1] : css;
}

function extractDarkBlock(css: string) {
  const match = css.match(/\[data-theme="dark"\]\s*\{([\s\S]*?)\}/);
  return match ? match[1] : "";
}

function parseTokenBlock(block: string) {
  const tokens: Record<string, string> = {};
  const re = /--color-([a-z0-9-]+)\s*:\s*([^;]+);/gi;
  let m;
  while ((m = re.exec(block))) {
    tokens[m[1]] = m[2].trim();
  }
  return tokens;
}

const tokenValues = parseTokenBlock(extractThemeBlock(cssSource));
const darkTokenValues = parseTokenBlock(extractDarkBlock(cssSource));

// Preset keys for prev/next navigation
const presetKeys = Object.keys(defaultPresets);

type ThemeSectionItemInput = {
  label: string;
  token: string;
  source?: "light" | "dark";
};

type ThemeSectionInput = {
  title: string;
  items: ThemeSectionItemInput[];
};

type ThemeSectionItem = {
  label: string;
  token: string;
  source: "light" | "dark";
};

type ThemeSection = {
  title: string;
  items: ThemeSectionItem[];
};

const rawSections: ThemeSectionInput[] = [
  {
    title: "Primary Theme Colors",
    items: [
      { label: "Background", token: "background" },
      { label: "Foreground", token: "foreground" },
      { label: "Primary", token: "primary" },
      { label: "Primary Foreground", token: "primary-foreground" },
    ],
  },
  {
    title: "Secondary & Accent Colors",
    items: [
      { label: "Secondary", token: "secondary" },
      { label: "Secondary Foreground", token: "secondary-foreground" },
      { label: "Accent", token: "accent" },
      { label: "Accent Foreground", token: "accent-foreground" },
    ],
  },
  {
    title: "UI Component Colors",
    items: [
      { label: "Card", token: "card" },
      { label: "Card Foreground", token: "card-foreground" },
      { label: "Popover", token: "popover" },
      { label: "Popover Foreground", token: "popover-foreground" },
      { label: "Muted", token: "muted" },
      { label: "Muted Foreground", token: "muted-foreground" },
    ],
  },
  {
    title: "Utility & Form Colors",
    items: [
      { label: "Border", token: "border" },
      { label: "Input", token: "input" },
      { label: "Ring", token: "ring" },
    ],
  },
  {
    title: "Status & Feedback Colors",
    items: [
      { label: "Destructive", token: "destructive" },
      { label: "Destructive Foreground", token: "destructive-foreground" },
    ],
  },
  {
    title: "Chart & Visualization Colors",
    items: [
      { label: "Chart 1", token: "chart-1" },
      { label: "Chart 2", token: "chart-2" },
      { label: "Chart 3", token: "chart-3" },
      { label: "Chart 4", token: "chart-4" },
      { label: "Chart 5", token: "chart-5" },
    ],
  },
  // {
  //   title: "Footer Colors",
  //   items: [
  //     { label: "Footer Background", token: "footer", source: "dark" },
  //     {
  //       label: "Footer Foreground",
  //       token: "footer-foreground",
  //       source: "dark",
  //     },
  //     { label: "Footer Primary", token: "footer-primary", source: "dark" },
  //     {
  //       label: "Footer Primary Foreground",
  //       token: "footer-primary-foreground",
  //       source: "dark",
  //     },
  //     { label: "Footer Accent", token: "footer-accent", source: "dark" },
  //     {
  //       label: "Footer Accent Foreground",
  //       token: "footer-accent-foreground",
  //       source: "dark",
  //     },
  //     { label: "Footer Border", token: "footer-border", source: "dark" },
  //     { label: "Footer Ring", token: "footer-ring", source: "dark" },
  //   ],
  // },
];

const sections: ThemeSection[] = rawSections.map((section) => ({
  ...section,
  items: section.items.map((item) => ({
    source: item.source ?? "light",
    label: item.label,
    token: item.token,
  })),
}));
---

<script is:inline>
  (() => {
    try {
      const cookieMatch = document.cookie.match(/(?:^|;)\s*theme=([^;]+)/);
      const cookieValue = cookieMatch ? decodeURIComponent(cookieMatch[1]) : "";
      const presetFromCookie = cookieValue ? cookieValue.split("|")[0] : "";
      const presetFromStorage =
        presetFromCookie || localStorage.getItem("theme-preset") || "default";

      const storedTheme =
        typeof localStorage !== "undefined" &&
        localStorage.getItem("starlight-theme");
      const resolvedTheme =
        storedTheme === "light" || storedTheme === "dark"
          ? storedTheme
          : window.matchMedia("(prefers-color-scheme: light)").matches
            ? "light"
            : "dark";

      const updateUrl = (rawUrl) => {
        try {
          const url = new URL(rawUrl, window.location.href);
          if (url.hostname !== "gradient.bejamas.com") return rawUrl;
          const hasTheme = url.searchParams.get("theme") === presetFromStorage;
          const hasMode = url.searchParams.get("mode") === resolvedTheme;
          if (hasTheme && hasMode) return rawUrl;
          url.searchParams.set("theme", presetFromStorage);
          url.searchParams.set("mode", resolvedTheme);
          return url.toString();
        } catch {
          return rawUrl;
        }
      };

      const updateSrcset = (srcset) => {
        if (!srcset) return srcset;
        return srcset
          .split(",")
          .map((entry) => {
            const parts = entry.trim().split(/\s+/);
            if (parts.length === 0) return entry;
            const updatedUrl = updateUrl(parts[0]);
            return parts.length > 1
              ? `${updatedUrl} ${parts.slice(1).join(" ")}`
              : updatedUrl;
          })
          .join(", ");
      };

      document.querySelectorAll("img").forEach((img) => {
        const currentSrc = img.getAttribute("src");
        if (currentSrc) {
          const nextSrc = updateUrl(currentSrc);
          if (nextSrc !== currentSrc) {
            img.setAttribute("src", nextSrc);
          }
        }

        const currentSrcset = img.getAttribute("srcset");
        if (currentSrcset) {
          const nextSrcset = updateSrcset(currentSrcset);
          if (nextSrcset !== currentSrcset) {
            img.setAttribute("srcset", nextSrcset);
          }
        }
      });
    } catch {}
  })();
</script>

<script>
  import "../utils/themes/apply-theme.ts";
</script>

<!-- Removed IndexedDB population; lean presets are used directly -->
<StarlightPage frontmatter={{ title: "Themes", template: "splash" }}>
  <!-- {JSON.stringify(leanPresets)} -->
  <div>
    <div class="not-content">
      <div class="flex items-end gap-2">
        <div>
          <Label for="preset-switcher" class="mb-2 font-medium"
            >Theme Presets</Label
          >
          <PresetSwitcher />
        </div>
        <Button
          variant="outline"
          id="previous-preset"
          size="icon"
          aria-label="Previous preset"><ArrowLeft class="size-4" /></Button
        >
        <Button
          variant="outline"
          id="next-preset"
          size="icon"
          aria-label="Next preset"><ArrowRight class="size-4" /></Button
        >
        <!-- <Button variant="outline">Copy Code <CodeXml class="size-4" /></Button> -->
      </div>
    </div>
    <div class="not-content mt-10">
      <section class="space-y-10 text-left">
        {
          sections.map((section) => (
            <div class="space-y-10 border-b pb-10 border-border">
              <h2 class="text-base font-semibold">{section.title}</h2>
              <div class="grid gap-4 sm:grid-cols-2 lg:grid-cols-4 border-bottom border-border">
                {section.items.map((item) => {
                  const source =
                    item.source === "dark" ? darkTokenValues : tokenValues;
                  const value = source[item.token] ?? "";
                  return (
                    <div class="flex items-center gap-5">
                      <div
                        class="size-15 rounded-md"
                        data-swatch={item.token}
                        data-source={item.source ?? "light"}
                        style={`background: var(--${item.token}); box-shadow: inset 0 0 0 1px color-mix(in oklch, var(--foreground) 15%, transparent);`}
                      />
                      <div class="text-left">
                        <div class="mb-1 text-sm font-medium">{item.label}</div>
                        <div
                          class="font-mono text-xs text-muted-foreground"
                          data-token={item.token}
                          data-source={item.source ?? "light"}
                        >
                          {value}
                        </div>
                      </div>
                    </div>
                  );
                })}
              </div>
            </div>
          ))
        }
      </section>
    </div>
  </div>
</StarlightPage>

<style is:global>
  @reference "tailwindcss";

  .content-panel {
    @apply text-center border-0 pt-14 pb-0;
  }

  .content-panel h1 {
    @apply text-5xl font-medium tracking-tight max-w-2xl text-balance mx-auto;
  }

  .sl-container {
    @apply max-w-7xl;
  }
</style>

<script>
  // Keep UI in sync with Starlight's theme toggle (and DOM state)
  function getThemeFromDom() {
    const apiTheme = window.astroThemeToggle?.getTheme?.();
    if (apiTheme === "dark" || apiTheme === "light") return apiTheme;
    const el = document.documentElement;
    const attr = el.getAttribute("data-theme");
    if (attr === "dark" || attr === "light") return attr;
    return el.classList.contains("dark") ? "dark" : "light";
  }

  function updateDataSourceFromDom() {
    const currentTheme = getThemeFromDom();
    document.querySelectorAll("[data-source]").forEach((el) => {
      el.setAttribute("data-source", currentTheme);
    });
  }

  // Initial sync
  updateDataSourceFromDom();

  // Astro swaps can re-mount DOM; re-sync after swap
  document.addEventListener("astro:after-swap", updateDataSourceFromDom);

  // Patch Starlight API to emit our event too
  if (window.astroThemeToggle?.setTheme) {
    const originalSet = window.astroThemeToggle.setTheme;
    window.astroThemeToggle.setTheme = (theme) => {
      originalSet(theme);
      window.dispatchEvent(
        new CustomEvent("theme-toggle-changed", { detail: { theme } }),
      );
      updateDataSourceFromDom();
    };
  }

  // Fallback: observe DOM mutations to theme markers
  const observer = new MutationObserver(updateDataSourceFromDom);
  observer.observe(document.documentElement, {
    attributes: true,
    attributeFilter: ["data-theme", "class"],
  });
</script>

<script type="module" define:vars={{ presetKeys }}>
  import {
    getStoredPreset,
    setStoredPreset,
    getCurrentMode,
    PRESET_CHANGE_EVENT,
  } from "../utils/themes/preset-store.ts";
  import { defaultPresets } from "../utils/themes/presets";

  // Build lean presets for UI updates
  const PRESETS = Object.fromEntries(
    Object.entries(defaultPresets).map(([key, p]) => [
      key,
      {
        label: p.label ?? key,
        styles: { light: p.styles?.light ?? {}, dark: p.styles?.dark ?? {} },
      },
    ])
  );

  const PRESET_KEYS = presetKeys;

  document.addEventListener("DOMContentLoaded", () => {
    const select = document.getElementById("preset-switcher");

    // Update token labels and swatch backgrounds for the themes page display
    const updateUIForPreset = (key) => {
      const preset = PRESETS[key];
      if (!preset) return;
      const light = (preset.styles && preset.styles.light) || {};
      const dark = (preset.styles && preset.styles.dark) || {};
      const mode = getCurrentMode();

      // Update displayed token values
      document.querySelectorAll("[data-token]").forEach((el) => {
        const token = el.getAttribute("data-token");
        const source = el.getAttribute("data-source") || "light";
        const map = source === "dark" ? dark : light;
        el.textContent = map[token] || "";
      });

      // Update swatch backgrounds
      document.querySelectorAll("[data-swatch]").forEach((el) => {
        const token = el.getAttribute("data-swatch");
        const map = mode === "dark" ? dark : light;
        const v = map[token];
        if (v) el.style.background = v;
      });
    };

    // Listen for preset changes (from PresetSwitcher or other sources)
    window.addEventListener(PRESET_CHANGE_EVENT, (e) => {
      const key = e.detail?.key;
      if (key) updateUIForPreset(key);
    });

    // Initial UI update
    const initial = getStoredPreset() || PRESET_KEYS[0];
    if (initial) updateUIForPreset(initial);

    // Helper to get swatches from a preset
    const getSwatches = (key) => {
      const preset = PRESETS[key];
      if (!preset) return undefined;
      return {
        primaryLight: preset.styles.light?.primary || "#000",
        accentLight: preset.styles.light?.accent || "#666",
        primaryDark: preset.styles.dark?.primary || "#fff",
        accentDark: preset.styles.dark?.accent || "#888",
      };
    };

    // Prev/Next buttons
    const previousPreset = document.getElementById("previous-preset");
    const nextPreset = document.getElementById("next-preset");

    if (previousPreset) {
      previousPreset.addEventListener("click", () => {
        const current = getStoredPreset() || PRESET_KEYS[0];
        const index = PRESET_KEYS.indexOf(current);
        const currentIndex = index === -1 ? 0 : index;
        const previousIndex =
          (currentIndex - 1 + PRESET_KEYS.length) % PRESET_KEYS.length;
        const key = PRESET_KEYS[previousIndex];
        const preset = PRESETS[key];
        setStoredPreset(key, getSwatches(key), preset?.label || key);
      });
    }

    if (nextPreset) {
      nextPreset.addEventListener("click", () => {
        const current = getStoredPreset() || PRESET_KEYS[0];
        const index = PRESET_KEYS.indexOf(current);
        const currentIndex = index === -1 ? 0 : index;
        const nextIndex = (currentIndex + 1) % PRESET_KEYS.length;
        const key = PRESET_KEYS[nextIndex];
        const preset = PRESETS[key];
        setStoredPreset(key, getSwatches(key), preset?.label || key);
      });
    }
  });
</script>
