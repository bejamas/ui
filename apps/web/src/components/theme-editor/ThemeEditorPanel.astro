---
/**
 * ThemeEditorPanel - Floating draggable panel for editing theme colors
 * Triggered by Cmd/Ctrl + e
 */

import { Button } from "@bejamas/ui/components/button";
import { Kbd } from "@bejamas/ui/components/kbd";
import {
  Dialog,
  DialogContent,
  DialogHeader,
  DialogTitle,
  DialogDescription,
  DialogFooter,
} from "@bejamas/ui/components/dialog";
import {
  DropdownMenu,
  DropdownMenuTrigger,
  DropdownMenuContent,
  DropdownMenuItem,
  DropdownMenuLabel,
  DropdownMenuSeparator,
} from "@bejamas/ui/components/dropdown-menu";
import { Input } from "@bejamas/ui/components/input";
import { Label } from "@bejamas/ui/components/label";
import {
  Select,
  SelectControl,
  SelectIndicator,
  SelectOption,
} from "@bejamas/ui/components/select";
import {
  Tabs,
  TabsList,
  TabsTrigger,
  TabsIndicator,
  TabsContent,
} from "@bejamas/ui/components/tabs";
import { Textarea } from "@bejamas/ui/components/textarea";
import {
  Tooltip,
  TooltipTrigger,
  TooltipContent,
} from "@bejamas/ui/components/tooltip";
import {
  X,
  GripHorizontal,
  Copy,
  Download,
  Plus,
  RotateCcw,
  Save,
  Trash2,
  Upload,
  Sparkles,
  Loader2,
  ImagePlus,
  ChevronDown,
} from "@lucide/astro";
import { defaultPresets } from "../../utils/themes/presets";
import ColorInput from "./ColorInput.astro";

// Color token sections (same as themes.astro)
const colorSections = [
  {
    title: "Primary",
    tokens: [
      { token: "background", label: "Background" },
      { token: "foreground", label: "Foreground" },
      { token: "primary", label: "Primary" },
      { token: "primary-foreground", label: "Primary FG" },
    ],
  },
  {
    title: "Secondary & Accent",
    tokens: [
      { token: "secondary", label: "Secondary" },
      { token: "secondary-foreground", label: "Secondary FG" },
      { token: "accent", label: "Accent" },
      { token: "accent-foreground", label: "Accent FG" },
    ],
  },
  {
    title: "UI Components",
    tokens: [
      { token: "card", label: "Card" },
      { token: "card-foreground", label: "Card FG" },
      { token: "popover", label: "Popover" },
      { token: "popover-foreground", label: "Popover FG" },
      { token: "muted", label: "Muted" },
      { token: "muted-foreground", label: "Muted FG" },
    ],
  },
  {
    title: "Utility & Form",
    tokens: [
      { token: "border", label: "Border" },
      { token: "input", label: "Input" },
      { token: "ring", label: "Ring" },
    ],
  },
  {
    title: "Status",
    tokens: [
      { token: "destructive", label: "Destructive" },
      { token: "destructive-foreground", label: "Destructive FG" },
    ],
  },
  {
    title: "Charts",
    tokens: [
      { token: "chart-1", label: "Chart 1" },
      { token: "chart-2", label: "Chart 2" },
      { token: "chart-3", label: "Chart 3" },
      { token: "chart-4", label: "Chart 4" },
      { token: "chart-5", label: "Chart 5" },
    ],
  },
];

const presetKeys = Object.keys(defaultPresets);
---

<theme-editor-panel
  id="theme-editor-panel"
  class="theme-editor-panel"
  data-presets={JSON.stringify(defaultPresets)}
>
  <!-- Header -->
  <div class="panel-header" data-slot="header">
    <div class="header-drag">
      <GripHorizontal class="size-4 text-muted-foreground" />
      <span class="header-title">Theme Editor</span>
    </div>
    <div class="header-actions">
      <Kbd>âŒ˜E</Kbd>
      <Button variant="ghost" size="icon-sm" data-slot="close" class="size-6">
        <X class="size-4" />
      </Button>
    </div>
  </div>

  <!-- Preset Selector -->
  <div class="panel-section preset-section">
    <div class="preset-row">
      <DropdownMenu class="flex-1">
        <DropdownMenuTrigger
          variant="outline"
          size="sm"
          class="w-full justify-between"
        >
          <div class="flex items-center gap-2 min-w-0">
            <div
              class="preset-swatches flex -space-x-1 items-center shrink-0"
              data-slot="preset-swatches"
            >
              <div
                class="size-3.5 rounded-full border border-border"
                data-slot="swatch-primary"
              >
              </div>
              <div
                class="size-3.5 rounded-full border border-border"
                data-slot="swatch-accent"
              >
              </div>
            </div>
            <span data-slot="preset-label" class="truncate">Default</span>
          </div>
          <ChevronDown class="size-4 opacity-50 shrink-0" />
        </DropdownMenuTrigger>
        <DropdownMenuContent class="w-[--trigger-width]">
          <DropdownMenuLabel>Built-in</DropdownMenuLabel>
          {
            presetKeys.map((key) => (
              <DropdownMenuItem data-value={key} class="gap-2">
                {/* Light mode swatches */}
                <div class="flex -space-x-1 items-center dark:hidden">
                  <div
                    class="size-4 rounded-full"
                    style={`background: ${defaultPresets[key].styles.light.primary}`}
                  />
                  <div
                    class="size-4 rounded-full"
                    style={`background: ${defaultPresets[key].styles.light.accent}`}
                  />
                </div>
                {/* Dark mode swatches */}
                <div class="hidden dark:flex -space-x-1 items-center">
                  <div
                    class="size-4 rounded-full border border-border"
                    style={`background: ${defaultPresets[key].styles.dark.primary}`}
                  />
                  <div
                    class="size-4 rounded-full border border-border"
                    style={`background: ${defaultPresets[key].styles.dark.accent}`}
                  />
                </div>
                <span class="truncate">{defaultPresets[key].label || key}</span>
              </DropdownMenuItem>
            ))
          }
        </DropdownMenuContent>
      </DropdownMenu>
      <Button
        variant="outline"
        size="icon-sm"
        data-slot="new-preset"
        title="Create new preset"
      >
        <Plus class="size-4" />
      </Button>
      <Button
        variant="outline"
        size="icon-sm"
        data-slot="delete-preset"
        title="Delete preset"
        disabled
      >
        <Trash2 class="size-4" />
      </Button>
    </div>
    <Input
      type="text"
      data-slot="preset-name"
      placeholder="Preset name..."
      class="hidden"
    />
  </div>

  <!-- Mode Tabs -->
  <div data-panel-mode-tabs>
    <Tabs defaultValue="light" class="mode-tabs-container">
      <TabsList
        class="w-full h-auto px-4 py-1 rounded-none border-b border-border bg-muted"
      >
        <TabsIndicator class="rounded-md" />
        <TabsTrigger
          value="light"
          data-mode="light"
          class="mode-tab flex-1 text-xs py-1.5"
        >
          Light
        </TabsTrigger>
        <TabsTrigger
          value="dark"
          data-mode="dark"
          class="mode-tab flex-1 text-xs py-1.5"
        >
          Dark
        </TabsTrigger>
      </TabsList>
    </Tabs>
  </div>

  <!-- Color Sections -->
  <div class="panel-content" data-slot="content">
    {
      colorSections.map((section) => (
        <div class="color-section border-b border-border last:border-b-0">
          <Button
            variant="ghost"
            class="section-header flex items-center justify-between w-full px-4 py-2.5 text-xs font-semibold uppercase tracking-wider rounded-none h-auto"
            data-slot="section-toggle"
          >
            <span>{section.title}</span>
            <ChevronDown class="chevron size-4 transition-transform duration-200" />
          </Button>
          <div class="section-content grid grid-cols-2 gap-3 px-4 py-3">
            {section.tokens.map((item) => (
              <ColorInput token={item.token} label={item.label} value="" />
            ))}
          </div>
        </div>
      ))
    }
  </div>

  <!-- Footer Actions -->
  <div class="panel-footer">
    <div class="footer-left">
      <Tooltip delay={400}>
        <TooltipTrigger asChild>
          <Button
            variant="outline"
            size="sm"
            data-slot="reset"
            title="Reset to original"
          >
            <RotateCcw class="size-3.5" />
          </Button>
          <TooltipContent>
            <p>Reset</p>
          </TooltipContent>
        </TooltipTrigger>
      </Tooltip>

      <Tooltip delay={400}>
        <TooltipTrigger asChild>
          <Button variant="outline" size="sm" data-action="import-css">
            <Upload class="size-3.5" />
          </Button>
          <TooltipContent>
            <p>Import CSS</p>
          </TooltipContent>
        </TooltipTrigger>
      </Tooltip>

      <Tooltip delay={400}>
        <TooltipTrigger asChild>
          <Button variant="outline" size="sm" data-action="export-json">
            Export
          </Button>
          <TooltipContent>
            <p>Export Theme</p>
          </TooltipContent>
        </TooltipTrigger>
      </Tooltip>

      <Button size="sm" data-slot="save" variant="outline">
        <!-- <Save class="size-3.5" /> -->
        Save
      </Button>
    </div>
    <div class="footer-right ml-auto">
      <Button size="sm" data-slot="ai-generate" title="AI Generate Palette">
        <Sparkles class="size-3.5" />
        AI
      </Button>
    </div>

    <!-- Import Dialog -->
    <Dialog id="import-dialog">
      <button
        type="button"
        data-slot="dialog-trigger"
        id="import-dialog-trigger"
        style="display: none;"></button>
      <DialogContent class="sm:max-w-lg import-dialog-content">
        <DialogHeader>
          <DialogTitle>Import Custom CSS</DialogTitle>
          <DialogDescription>
            Paste your CSS file below to customize the theme colors. Make sure
            to include variables like --primary, --background, etc.
          </DialogDescription>
        </DialogHeader>
        <div class="import-textarea-wrapper mt-4">
          <Textarea
            id="import-css-textarea"
            class="font-mono text-xs min-h-[200px]"
            placeholder={`:root {\n  --background: oklch(1 0 0);\n  --foreground: oklch(0.2 0.044 250);\n  --primary: oklch(0.6 0.2 280);\n  /* And more */\n}\n\n.dark {\n  --background: oklch(0.2 0.02 250);\n  --foreground: oklch(0.97 0.02 250);\n  /* And more */\n}`}
          />
        </div>
        <DialogFooter>
          <Button variant="outline" data-slot="dialog-close">Cancel</Button>
          <Button id="import-confirm-btn">Import</Button>
        </DialogFooter>
      </DialogContent>
    </Dialog>

    <!-- Export Dialog -->
    <Dialog id="export-json-dialog">
      <button
        type="button"
        data-slot="dialog-trigger"
        id="export-json-dialog-trigger"
        style="display: none;"></button>
      <DialogContent class="sm:max-w-2xl w-full export-dialog-content">
        <DialogHeader>
          <DialogTitle>Export</DialogTitle>
          <DialogDescription>
            Copy the theme configuration in your preferred format.
          </DialogDescription>
        </DialogHeader>
        <Tabs
          defaultValue="json"
          class="export-type-tabs mt-4"
          id="export-type-tabs"
        >
          <div class="export-options-row flex items-center gap-3">
            <TabsList class="h-9">
              <TabsTrigger value="json" class="text-sm px-2">JSON</TabsTrigger>
              <TabsTrigger value="css" class="text-sm px-2">CSS</TabsTrigger>
              <TabsIndicator />
            </TabsList>
            <div class="flex items-center gap-2 ml-auto">
              <Label
                for="export-format-select"
                class="text-sm whitespace-nowrap">Colors:</Label
              >
              <Select>
                <SelectIndicator />
                <SelectControl id="export-format-select" size="sm">
                  <SelectOption value="hsl">HSL</SelectOption>
                  <SelectOption value="rgb">RGB</SelectOption>
                  <SelectOption value="hex">HEX</SelectOption>
                  <SelectOption value="oklch" selected>OKLCH</SelectOption>
                </SelectControl>
              </Select>
            </div>
          </div>
          <TabsContent value="json" class="mt-0">
            <pre
              class="export-code-block max-w-[622px] font-mono text-xs max-h-[300px] overflow-auto rounded-md border bg-muted/50 p-4"><code id="export-code-json" class="language-json" /></pre>
          </TabsContent>
          <TabsContent value="css" class="mt-0">
            <pre
              class="export-code-block max-w-[622px] font-mono text-xs max-h-[300px] overflow-auto rounded-md border bg-muted/50 p-4"><code id="export-code-css" class="language-css" /></pre>
          </TabsContent>
        </Tabs>
        <DialogFooter>
          <Button variant="outline" data-slot="dialog-close">Close</Button>
          <Button id="export-json-copy-btn">Copy to Clipboard</Button>
        </DialogFooter>
      </DialogContent>
    </Dialog>

    <!-- AI Generate Dialog -->
    <Dialog id="ai-generate-dialog">
      <button
        type="button"
        data-slot="dialog-trigger"
        id="ai-generate-dialog-trigger"
        style="display: none;"></button>
      <DialogContent class="sm:max-w-lg ai-dialog-content">
        <DialogHeader>
          <DialogTitle>
            <span class="flex items-center gap-2">
              <Sparkles class="size-5 text-accent" />
              AI Generate Palette
            </span>
          </DialogTitle>
          <DialogDescription>
            Describe the palette you want to create. You can mention brands,
            moods, colors, or upload reference images.
          </DialogDescription>
        </DialogHeader>

        <div class="ai-form">
          <div class="ai-prompt-wrapper">
            <Textarea
              id="ai-prompt-textarea"
              class="min-h-[80px]"
              placeholder="e.g., A warm and inviting theme with earthy browns and cream accents for a cozy atmosphere..."
              rows={3}
            />
          </div>

          <div class="ai-images-section">
            <Label class="ai-images-label">
              <ImagePlus class="size-4" />
              <span>Reference Images (optional)</span>
            </Label>
            <div class="ai-images-dropzone" id="ai-images-dropzone">
              <input
                type="file"
                id="ai-images-input"
                accept="image/*"
                multiple
                class="ai-images-file-input"
              />
              <div class="dropzone-content">
                <ImagePlus class="size-6 text-muted-foreground" />
                <span>Drop images or click to upload</span>
                <span class="dropzone-hint">Max 3 images, PNG/JPG</span>
              </div>
            </div>
            <div class="ai-images-preview" id="ai-images-preview"></div>
          </div>

          <div class="ai-status" id="ai-status" style="display: none;">
            <span id="ai-status-icon" class="ai-status-icon">
              <Loader2 class="size-4 animate-spin" />
            </span>
            <span id="ai-status-text">Generating palette...</span>
          </div>

          <div class="ai-reasoning" id="ai-reasoning" style="display: none;">
            <details>
              <summary>AI Reasoning</summary>
              <div class="ai-reasoning-content" id="ai-reasoning-content"></div>
            </details>
          </div>
        </div>

        <DialogFooter>
          <Button variant="outline" data-slot="dialog-close">Cancel</Button>
          <Button id="ai-generate-confirm-btn">
            <Sparkles class="size-4" />
            Generate
          </Button>
        </DialogFooter>
      </DialogContent>
    </Dialog>
  </div>

  <!-- Theme Editor toggle button - positioned after panel for CSS sibling selector -->
  <!-- <button
  type="button"
  id="theme-editor-toggle-btn"
  class="theme-editor-fab"
  aria-label="Open theme editor (Cmd/Ctrl + E)"
  title="Open theme editor (Cmd/Ctrl + E)"
>
  <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
    <circle cx="13.5" cy="6.5" r="0.5" fill="currentColor"/>
    <circle cx="17.5" cy="10.5" r="0.5" fill="currentColor"/>
    <circle cx="8.5" cy="7.5" r="0.5" fill="currentColor"/>
    <circle cx="6.5" cy="12.5" r="0.5" fill="currentColor"/>
    <path d="M12 2C6.5 2 2 6.5 2 12s4.5 10 10 10c.926 0 1.648-.746 1.648-1.688 0-.437-.18-.835-.437-1.125-.29-.289-.438-.652-.438-1.125a1.64 1.64 0 0 1 1.668-1.668h1.996c3.051 0 5.555-2.503 5.555-5.555C21.965 6.012 17.461 2 12 2z"/>
  </svg>
</button> -->

  <style is:global>
    /* Floating Action Button */
    .theme-editor-fab {
      position: fixed;
      bottom: 20px;
      right: 20px;
      z-index: 9998;
      width: 40px;
      height: 40px;
      display: flex;
      align-items: center;
      justify-content: center;
      background: var(--primary);
      color: var(--primary-foreground);
      border: none;
      border-radius: 12px;
      cursor: pointer;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
      transition:
        transform 0.15s,
        box-shadow 0.15s,
        opacity 0.15s;
    }

    .theme-editor-fab:hover {
      transform: scale(1.05);
      box-shadow: 0 6px 16px rgba(0, 0, 0, 0.2);
    }

    .theme-editor-fab:active {
      transform: scale(0.95);
    }

    /* Hide FAB when panel is open */
    .theme-editor-panel.open + .theme-editor-fab {
      opacity: 0;
      pointer-events: none;
    }

    .theme-editor-panel {
      position: fixed;
      top: 80px;
      right: 20px;
      width: 320px;
      max-height: calc(100vh - 100px);
      background: var(--popover, #fff);
      border: 1px solid var(--border);
      border-radius: 0.75rem;
      box-shadow: 0 25px 50px -12px rgba(0, 0, 0, 0.25);
      z-index: 9999;
      display: none;
      flex-direction: column;
      overflow: hidden;
      font-size: 0.875rem;
    }

    .theme-editor-panel.open {
      display: flex;
    }

    .panel-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 0.75rem 1rem;
      border-bottom: 1px solid var(--border);
      cursor: move;
      user-select: none;
      background: var(--muted);
    }

    .header-drag {
      display: flex;
      align-items: center;
      gap: 0.5rem;
    }

    .header-title {
      font-weight: 600;
      font-size: 0.875rem;
    }

    .header-actions {
      display: flex;
      align-items: center;
      gap: 0.5rem;
    }

    .shortcut-hint {
      font-size: 0.625rem;
      padding: 0.125rem 0.375rem;
      background: var(--secondary);
      border-radius: 0.25rem;
      color: var(--muted-foreground);
      font-family: ui-monospace, monospace;
    }

    .panel-section {
      padding: 0.75rem 1rem;
      border-bottom: 1px solid var(--border);
    }

    .preset-section {
      display: flex;
      flex-direction: column;
      gap: 0.5rem;
    }

    .preset-row {
      display: flex;
      gap: 0.5rem;
    }

    .mode-tabs-container {
      gap: 0;
    }

    .color-section.collapsed .section-content {
      display: none;
    }

    .color-section.collapsed .chevron {
      transform: rotate(-90deg);
    }

    .panel-content {
      flex: 1;
      overflow-y: auto;
      padding: 0.5rem 0;
    }

    .panel-footer {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 0.75rem 1rem;
      border-top: 1px solid var(--border);
      background: var(--muted);
    }

    .footer-left,
    .footer-right {
      display: flex;
      gap: 0.375rem;
    }

    /* Import Dialog */
    .import-dialog-content {
      z-index: 10001;
    }

    /* Export Dialog */
    .export-dialog-content {
      z-index: 10001;
    }

    .export-code-block {
      white-space: pre;
      word-wrap: normal;
      overflow-x: auto;
      tab-size: 2;
      line-height: 1.6;
      background: var(--muted) !important;
      margin: 0;
    }

    .export-code-block code {
      display: block;
      font-family:
        ui-monospace, SFMono-Regular, "SF Mono", Menlo, Consolas,
        "Liberation Mono", monospace;
      background: transparent !important;
    }

    /* Prism light theme (default) */
    .export-code-block code[class*="language-"],
    .export-code-block pre[class*="language-"] {
      color: black;
      background: none;
      text-shadow: 0 1px white;
    }

    .export-code-block .token.comment,
    .export-code-block .token.prolog,
    .export-code-block .token.doctype,
    .export-code-block .token.cdata {
      color: slategray;
    }

    .export-code-block .token.punctuation {
      color: #999;
    }

    .export-code-block .token.namespace {
      opacity: 0.7;
    }

    .export-code-block .token.property,
    .export-code-block .token.tag,
    .export-code-block .token.boolean,
    .export-code-block .token.number,
    .export-code-block .token.constant,
    .export-code-block .token.symbol,
    .export-code-block .token.deleted {
      color: #905;
    }

    .export-code-block .token.selector,
    .export-code-block .token.attr-name,
    .export-code-block .token.string,
    .export-code-block .token.char,
    .export-code-block .token.builtin,
    .export-code-block .token.inserted {
      color: #690;
    }

    .export-code-block .token.operator,
    .export-code-block .token.entity,
    .export-code-block .token.url,
    .export-code-block .language-css .token.string,
    .export-code-block .style .token.string {
      color: #9a6e3a;
    }

    .export-code-block .token.atrule,
    .export-code-block .token.attr-value,
    .export-code-block .token.keyword {
      color: #07a;
    }

    .export-code-block .token.function,
    .export-code-block .token.class-name {
      color: #dd4a68;
    }

    .export-code-block .token.regex,
    .export-code-block .token.important,
    .export-code-block .token.variable {
      color: #e90;
    }

    .export-code-block .token.important,
    .export-code-block .token.bold {
      font-weight: bold;
    }

    .export-code-block .token.italic {
      font-style: italic;
    }

    /* Prism dark theme */
    .dark .export-code-block code[class*="language-"],
    .dark .export-code-block pre[class*="language-"] {
      color: white;
      background: none;
      text-shadow: 0 -0.1em 0.2em black;
    }

    .dark .export-code-block .token.comment,
    .dark .export-code-block .token.prolog,
    .dark .export-code-block .token.doctype,
    .dark .export-code-block .token.cdata {
      color: hsl(30, 20%, 50%);
    }

    .dark .export-code-block .token.punctuation {
      opacity: 0.7;
    }

    .dark .export-code-block .token.namespace {
      opacity: 0.7;
    }

    .dark .export-code-block .token.property,
    .dark .export-code-block .token.tag,
    .dark .export-code-block .token.boolean,
    .dark .export-code-block .token.number,
    .dark .export-code-block .token.constant,
    .dark .export-code-block .token.symbol {
      color: hsl(350, 40%, 70%);
    }

    .dark .export-code-block .token.selector,
    .dark .export-code-block .token.attr-name,
    .dark .export-code-block .token.string,
    .dark .export-code-block .token.char,
    .dark .export-code-block .token.builtin,
    .dark .export-code-block .token.inserted {
      color: hsl(75, 70%, 60%);
    }

    .dark .export-code-block .token.operator,
    .dark .export-code-block .token.entity,
    .dark .export-code-block .token.url,
    .dark .export-code-block .language-css .token.string,
    .dark .export-code-block .style .token.string,
    .dark .export-code-block .token.variable {
      color: hsl(40, 90%, 60%);
    }

    .dark .export-code-block .token.atrule,
    .dark .export-code-block .token.attr-value,
    .dark .export-code-block .token.keyword {
      color: hsl(350, 40%, 70%);
    }

    .dark .export-code-block .token.regex,
    .dark .export-code-block .token.important {
      color: #e90;
    }

    .dark .export-code-block .token.important,
    .dark .export-code-block .token.bold {
      font-weight: bold;
    }

    .dark .export-code-block .token.italic {
      font-style: italic;
    }

    .dark .export-code-block .token.deleted {
      color: red;
    }

    /* Toast notification */
    .theme-editor-toast {
      position: fixed;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
      padding: 0.75rem 1.25rem;
      background: var(--foreground);
      color: var(--background);
      border-radius: 0.5rem;
      font-size: 0.875rem;
      font-weight: 500;
      z-index: 10000;
      animation: toast-in 0.3s ease;
    }

    @keyframes toast-in {
      from {
        opacity: 0;
        transform: translateX(-50%) translateY(10px);
      }
      to {
        opacity: 1;
        transform: translateX(-50%) translateY(0);
      }
    }

    /* AI Generate Button */
    .ai-btn {
      background: linear-gradient(
        135deg,
        var(--accent) 0%,
        var(--primary) 100%
      ) !important;
      color: var(--accent-foreground) !important;
      border-color: var(--accent) !important;
    }

    .ai-btn:hover {
      opacity: 0.9;
    }

    /* AI Generate Dialog */
    .ai-dialog-content {
      z-index: 10001;
    }

    .ai-form {
      display: flex;
      flex-direction: column;
      gap: 1rem;
      margin-top: 1rem;
    }

    .ai-prompt-wrapper {
      width: 100%;
    }

    .ai-images-section {
      display: flex;
      flex-direction: column;
      gap: 0.5rem;
    }

    .ai-images-label {
      display: flex;
      align-items: center;
      gap: 0.5rem;
      font-size: 0.8125rem;
      font-weight: 500;
      color: var(--foreground);
    }

    .ai-images-dropzone {
      position: relative;
      border: 2px dashed var(--border);
      border-radius: 0.5rem;
      padding: 1.5rem;
      text-align: center;
      transition:
        border-color 0.15s,
        background 0.15s;
      cursor: pointer;
    }

    .ai-images-dropzone:hover,
    .ai-images-dropzone.dragover {
      border-color: var(--accent);
      background: var(--accent) / 0.05;
    }

    .ai-images-file-input {
      position: absolute;
      inset: 0;
      opacity: 0;
      cursor: pointer;
    }

    .dropzone-content {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 0.5rem;
      pointer-events: none;
    }

    .dropzone-content span {
      font-size: 0.8125rem;
      color: var(--muted-foreground);
    }

    .dropzone-hint {
      font-size: 0.6875rem !important;
      opacity: 0.7;
    }

    .ai-images-preview {
      display: flex;
      gap: 0.5rem;
      flex-wrap: wrap;
    }

    .ai-image-preview {
      position: relative;
      width: 64px;
      height: 64px;
      border-radius: 0.375rem;
      overflow: hidden;
      border: 1px solid var(--border);
    }

    .ai-image-preview img {
      width: 100%;
      height: 100%;
      object-fit: cover;
    }

    .ai-image-preview button {
      position: absolute;
      top: 2px;
      right: 2px;
      width: 18px;
      height: 18px;
      display: flex;
      align-items: center;
      justify-content: center;
      background: var(--destructive);
      color: var(--destructive-foreground);
      border: none;
      border-radius: 50%;
      cursor: pointer;
      font-size: 12px;
      line-height: 1;
    }

    .ai-status {
      display: flex;
      align-items: center;
      gap: 0.5rem;
      padding: 0.75rem;
      background: var(--muted);
      border-radius: 0.5rem;
      font-size: 0.8125rem;
      color: var(--muted-foreground);
    }

    .ai-status-icon {
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .ai-status-icon .animate-spin {
      animation: spin 1s linear infinite;
    }

    @keyframes spin {
      from {
        transform: rotate(0deg);
      }
      to {
        transform: rotate(360deg);
      }
    }

    .ai-reasoning {
      font-size: 0.8125rem;
    }

    .ai-reasoning summary {
      cursor: pointer;
      color: var(--muted-foreground);
      padding: 0.5rem 0;
    }

    .ai-reasoning summary:hover {
      color: var(--foreground);
    }

    .ai-reasoning-content {
      padding: 0.75rem;
      background: var(--muted);
      border-radius: 0.375rem;
      font-size: 0.75rem;
      line-height: 1.5;
      color: var(--muted-foreground);
      max-height: 150px;
      overflow-y: auto;
      white-space: pre-wrap;
    }

    .ai-generate-btn {
      background: linear-gradient(
        135deg,
        var(--accent) 0%,
        var(--primary) 100%
      );
      border-color: var(--accent);
    }

    .ai-generate-btn:disabled {
      opacity: 0.6;
      cursor: not-allowed;
    }
  </style>

  <script>
    import {
      applyThemeToElement,
      applyThemeToCss,
    } from "../../utils/themes/apply-theme";
    import {
      getStoredPreset,
      setStoredPreset,
      getCurrentMode,
      PRESET_CHANGE_EVENT,
    } from "../../utils/themes/preset-store";
    import { defaultPresets } from "../../utils/themes/presets";
    import {
      getAllPresets,
      saveCustomPreset,
      deleteCustomPreset,
      generatePresetId,
      getCustomPresets,
      CUSTOM_PRESETS_CHANGE_EVENT,
      type CustomPreset,
    } from "../../utils/themes/custom-presets-store";
    import type { ThemePreset, ThemeStyleProps } from "../../utils/types/theme";
    // Prism.js for syntax highlighting
    import Prism from "prismjs";
    import "prismjs/components/prism-json";
    import "prismjs/components/prism-css";

    class ThemeEditorPanel extends HTMLElement {
      private isDragging = false;
      private dragOffset = { x: 0, y: 0 };
      private currentPresetId: string = "";
      private currentMode: "light" | "dark" = "light";
      private workingStyles: {
        light: Partial<ThemeStyleProps>;
        dark: Partial<ThemeStyleProps>;
      } = { light: {}, dark: {} };
      private originalStyles: {
        light: Partial<ThemeStyleProps>;
        dark: Partial<ThemeStyleProps>;
      } = { light: {}, dark: {} };
      private isCustomPreset = false;
      private isCreatingNew = false;

      // Elements
      private header: HTMLElement | null = null;
      private closeBtn: HTMLElement | null = null;
      private presetSelect: HTMLElement | null = null;
      private presetLabel: HTMLElement | null = null;
      private presetSwatchPrimary: HTMLElement | null = null;
      private presetSwatchAccent: HTMLElement | null = null;
      private presetDropdownContent: HTMLElement | null = null;
      private presetNameInput: HTMLInputElement | null = null;
      private newPresetBtn: HTMLElement | null = null;
      private deletePresetBtn: HTMLElement | null = null;
      private modeTabs: HTMLElement | null = null;
      private content: HTMLElement | null = null;
      private resetBtn: HTMLElement | null = null;
      private importDropdown: HTMLElement | null = null;
      private exportDropdown: HTMLElement | null = null;
      private aiGenerateBtn: HTMLElement | null = null;
      private saveBtn: HTMLElement | null = null;

      // AI state
      private aiImages: { data: string; mediaType: string }[] = [];

      connectedCallback() {
        this.header = this.querySelector('[data-slot="header"]');
        this.closeBtn = this.querySelector('[data-slot="close"]');
        this.presetLabel = this.querySelector('[data-slot="preset-label"]');
        this.presetSwatchPrimary = this.querySelector(
          '[data-slot="swatch-primary"]',
        );
        this.presetSwatchAccent = this.querySelector(
          '[data-slot="swatch-accent"]',
        );
        this.presetDropdownContent = this.querySelector(
          '[data-slot="dropdown-menu-content"]',
        );
        this.presetNameInput = this.querySelector('[data-slot="preset-name"]');
        this.newPresetBtn = this.querySelector('[data-slot="new-preset"]');
        this.deletePresetBtn = this.querySelector(
          '[data-slot="delete-preset"]',
        );
        this.modeTabs = this.querySelector("[data-panel-mode-tabs]");
        this.content = this.querySelector('[data-slot="content"]');
        this.resetBtn = this.querySelector('[data-slot="reset"]');
        this.importDropdown = this.querySelector(
          "[data-panel-import-dropdown]",
        );
        this.importCssBtn = this.querySelector('[data-action="import-css"]');
        this.exportJsonBtn = this.querySelector('[data-action="export-json"]');
        this.exportDropdown = this.querySelector(
          "[data-panel-export-dropdown]",
        );
        this.aiGenerateBtn = this.querySelector('[data-slot="ai-generate"]');
        this.saveBtn = this.querySelector('[data-slot="save"]');

        this.setupDragging();
        this.setupEventListeners();
        this.loadInitialState();

        // Global keyboard shortcut
        document.addEventListener("keydown", this.handleKeydown.bind(this));

        // Listen for preset changes from other sources
        window.addEventListener(
          PRESET_CHANGE_EVENT,
          this.handleExternalPresetChange.bind(this),
        );
        window.addEventListener(
          CUSTOM_PRESETS_CHANGE_EVENT,
          this.refreshPresetList.bind(this),
        );

        // Listen for theme changes from ThemeSwitcher
        window.addEventListener(
          "theme-toggle-changed",
          this.handleExternalThemeChange.bind(this),
        );
      }

      private handleExternalThemeChange(e: Event) {
        const customEvent = e as CustomEvent<{ theme: string }>;
        const theme = customEvent.detail?.theme;
        if (theme === "light" || theme === "dark") {
          // Only update if different to avoid loops
          if (this.currentMode !== theme) {
            this.switchMode(theme, true);
          }
        }
      }

      disconnectedCallback() {
        document.removeEventListener("keydown", this.handleKeydown.bind(this));
      }

      private handleKeydown(e: KeyboardEvent) {
        // Cmd/Ctrl + . to toggle panel
        if ((e.metaKey || e.ctrlKey) && e.key === ".") {
          e.preventDefault();
          this.toggle();
        }
        // Escape to close (but not if a dialog is open)
        if (e.key === "Escape" && this.classList.contains("open")) {
          // Check if any dialog is currently open
          const openDialog = document.querySelector(
            '[data-slot="dialog-overlay"][data-state="open"]',
          );
          if (!openDialog) {
            this.close();
          }
        }
      }

      private setupDragging() {
        if (!this.header) return;

        this.header.addEventListener("mousedown", (e) => {
          if ((e.target as HTMLElement).closest("button")) return;
          this.isDragging = true;
          const rect = this.getBoundingClientRect();
          this.dragOffset = {
            x: e.clientX - rect.left,
            y: e.clientY - rect.top,
          };
          this.style.transition = "none";
        });

        document.addEventListener("mousemove", (e) => {
          if (!this.isDragging) return;
          const x = e.clientX - this.dragOffset.x;
          const y = e.clientY - this.dragOffset.y;

          // Keep panel within viewport
          const maxX = window.innerWidth - this.offsetWidth;
          const maxY = window.innerHeight - this.offsetHeight;

          this.style.left = `${Math.max(0, Math.min(x, maxX))}px`;
          this.style.top = `${Math.max(0, Math.min(y, maxY))}px`;
          this.style.right = "auto";
        });

        document.addEventListener("mouseup", () => {
          this.isDragging = false;
          this.style.transition = "";
        });
      }

      private setupEventListeners() {
        // Close button
        this.closeBtn?.addEventListener("click", () => this.close());

        // Preset dropdown menu item clicks
        this.presetDropdownContent?.addEventListener("click", (e) => {
          const item = (e.target as HTMLElement).closest(
            '[data-slot="dropdown-menu-item"]',
          );
          if (item) {
            const id = (item as HTMLElement).dataset.value;
            if (id) {
              this.loadPreset(id);
            }
          }
        });

        // New preset button
        this.newPresetBtn?.addEventListener("click", () =>
          this.startNewPreset(),
        );

        // Delete preset button
        this.deletePresetBtn?.addEventListener("click", () =>
          this.deleteCurrentPreset(),
        );

        // Preset name input
        this.presetNameInput?.addEventListener("keydown", (e) => {
          if (e.key === "Enter") {
            this.confirmNewPreset();
          } else if (e.key === "Escape") {
            this.cancelNewPreset();
          }
        });

        // Mode tabs - use event delegation to work with @data-slot/tabs
        this.modeTabs?.addEventListener("click", (e) => {
          const tab = (e.target as HTMLElement).closest(".mode-tab");
          if (tab) {
            const mode = (tab as HTMLElement).dataset.mode as "light" | "dark";
            if (mode) {
              this.switchMode(mode);
            }
          }
        });

        // Section toggles
        this.content
          ?.querySelectorAll('[data-slot="section-toggle"]')
          .forEach((toggle) => {
            toggle.addEventListener("click", () => {
              toggle.closest(".color-section")?.classList.toggle("collapsed");
            });
          });

        // Color changes
        this.addEventListener("color-change", ((e: CustomEvent) => {
          const { token, value } = e.detail;
          this.updateColor(token, value);
        }) as EventListener);

        // Footer buttons
        this.resetBtn?.addEventListener("click", () => this.resetToOriginal());
        this.aiGenerateBtn?.addEventListener("click", () =>
          this.openAIDialog(),
        );
        this.saveBtn?.addEventListener("click", () => this.savePreset());

        // Import dropdown
        // this.importDropdown?.addEventListener("click", (e) => {
        //   const item = (e.target as HTMLElement).closest("[data-action]");
        //   if (item) {
        //     const action = (item as HTMLElement).dataset.action;
        //     if (action === "import-css") {
        //       this.openImportDialog();
        //     }
        //   }
        // });

        this.importCssBtn?.addEventListener("click", () =>
          this.openImportDialog(),
        );

        // Export JSON button
        this.exportJsonBtn?.addEventListener("click", () =>
          this.openExportJsonDialog(),
        );

        // Export dropdown
        // this.exportDropdown?.addEventListener("click", (e) => {
        //   const item = (e.target as HTMLElement).closest("[data-action]");
        //   if (item) {
        //     const action = (item as HTMLElement).dataset.action;
        //     if (action === "export-json") {
        //       this.openExportJsonDialog();
        //     }
        //   }
        // });

        // AI dialog confirm button - use event delegation
        if (!(window as any).__aiGenerateHandler) {
          (window as any).__aiGenerateHandler = (e: Event) => {
            const target = e.target as HTMLElement;
            if (target.closest("#ai-generate-confirm-btn")) {
              const panel = document.getElementById(
                "theme-editor-panel",
              ) as ThemeEditorPanel | null;
              panel?.handleAIGenerate();
            }
          };
          document.addEventListener(
            "click",
            (window as any).__aiGenerateHandler,
          );
        }

        // Setup AI image upload handlers
        this.setupAIImageHandlers();

        // Import dialog confirm button - use event delegation on document for dynamic content
        // Guard to prevent multiple listeners after View Transitions
        if (!(window as any).__importConfirmHandler) {
          (window as any).__importConfirmHandler = (e: Event) => {
            const target = e.target as HTMLElement;
            if (target.closest("#import-confirm-btn")) {
              const panel = document.getElementById(
                "theme-editor-panel",
              ) as ThemeEditorPanel | null;
              panel?.handleImport();
            }
          };
          document.addEventListener(
            "click",
            (window as any).__importConfirmHandler,
          );
        }

        // Export JSON copy button - use event delegation
        if (!(window as any).__exportJsonCopyHandler) {
          (window as any).__exportJsonCopyHandler = (e: Event) => {
            const target = e.target as HTMLElement;
            if (target.closest("#export-json-copy-btn")) {
              const panel = document.getElementById(
                "theme-editor-panel",
              ) as ThemeEditorPanel | null;
              panel?.handleExportJsonCopy();
            }
          };
          document.addEventListener(
            "click",
            (window as any).__exportJsonCopyHandler,
          );
        }

        // Export format select change - use event delegation
        if (!(window as any).__exportFormatChangeHandler) {
          (window as any).__exportFormatChangeHandler = (e: Event) => {
            const target = e.target as HTMLElement;
            if (target.closest("#export-format-select")) {
              const panel = document.getElementById(
                "theme-editor-panel",
              ) as ThemeEditorPanel | null;
              panel?.updateExportContent();
            }
          };
          document.addEventListener(
            "change",
            (window as any).__exportFormatChangeHandler,
          );
        }

        // Export type tabs change - use event delegation
        if (!(window as any).__exportTypeTabsHandler) {
          (window as any).__exportTypeTabsHandler = (e: Event) => {
            const customEvent = e as CustomEvent;
            const target = e.target as HTMLElement;
            if (
              target.closest("#export-type-tabs") &&
              customEvent.detail?.value
            ) {
              const panel = document.getElementById(
                "theme-editor-panel",
              ) as ThemeEditorPanel | null;
              panel?.setExportType(customEvent.detail.value as "json" | "css");
            }
          };
          document.addEventListener(
            "tabs:change",
            (window as any).__exportTypeTabsHandler,
          );
        }
      }

      private loadInitialState() {
        this.currentMode = getCurrentMode();
        this.updateModeTabsUI();
        this.refreshPresetList();

        const storedPreset = getStoredPreset();
        if (storedPreset) {
          this.loadPreset(storedPreset);
        } else {
          this.loadPreset(Object.keys(defaultPresets)[0]);
        }
      }

      private refreshPresetList() {
        if (!this.presetDropdownContent) return;

        const allPresets = getAllPresets();

        // Clear existing items
        this.presetDropdownContent.innerHTML = "";

        // Built-in presets label
        const builtInLabel = document.createElement("div");
        builtInLabel.setAttribute("data-slot", "dropdown-menu-label");
        builtInLabel.className = "px-2 py-1.5 text-sm font-medium";
        builtInLabel.textContent = "Built-in";
        this.presetDropdownContent.appendChild(builtInLabel);

        // Built-in preset items
        Object.entries(allPresets).forEach(([id, preset]) => {
          if (!preset.isCustom) {
            const item = document.createElement("div");
            item.setAttribute("role", "menuitem");
            item.setAttribute("tabindex", "0");
            item.setAttribute("data-slot", "dropdown-menu-item");
            item.setAttribute("data-value", id);
            item.className =
              "relative flex cursor-default select-none items-center gap-2 rounded-sm px-2 py-1.5 text-sm outline-none data-highlighted:bg-accent data-highlighted:text-accent-foreground";
            item.textContent = preset.name || id;
            this.presetDropdownContent!.appendChild(item);
          }
        });

        // Custom presets
        const customPresets = Object.entries(allPresets).filter(
          ([, p]) => p.isCustom,
        );
        if (customPresets.length > 0) {
          // Separator
          const separator = document.createElement("div");
          separator.setAttribute("data-slot", "dropdown-menu-separator");
          separator.className = "-mx-1 my-1 h-px bg-border";
          this.presetDropdownContent.appendChild(separator);

          // Custom label
          const customLabel = document.createElement("div");
          customLabel.setAttribute("data-slot", "dropdown-menu-label");
          customLabel.className = "px-2 py-1.5 text-sm font-medium";
          customLabel.textContent = "Custom";
          this.presetDropdownContent.appendChild(customLabel);

          // Custom preset items
          customPresets.forEach(([id, preset]) => {
            const item = document.createElement("div");
            item.setAttribute("role", "menuitem");
            item.setAttribute("tabindex", "0");
            item.setAttribute("data-slot", "dropdown-menu-item");
            item.setAttribute("data-value", id);
            item.className =
              "relative flex cursor-default select-none items-center gap-2 rounded-sm px-2 py-1.5 text-sm outline-none data-highlighted:bg-accent data-highlighted:text-accent-foreground";

            const lightStyles = preset.styles?.light || {};
            const darkStyles = preset.styles?.dark || {};

            // Light mode swatches
            const lightSwatches = document.createElement("div");
            lightSwatches.className =
              "flex -space-x-1 items-center dark:hidden";
            lightSwatches.innerHTML = `
            <div class="size-4 rounded-full" style="background: ${lightStyles.primary || "#888"}"></div>
            <div class="size-4 rounded-full" style="background: ${lightStyles.accent || "#888"}"></div>
          `;
            item.appendChild(lightSwatches);

            // Dark mode swatches
            const darkSwatches = document.createElement("div");
            darkSwatches.className = "hidden dark:flex -space-x-1 items-center";
            darkSwatches.innerHTML = `
            <div class="size-4 rounded-full border border-border" style="background: ${darkStyles.primary || "#888"}"></div>
            <div class="size-4 rounded-full border border-border" style="background: ${darkStyles.accent || "#888"}"></div>
          `;
            item.appendChild(darkSwatches);

            // Label
            const label = document.createElement("span");
            label.className = "truncate";
            label.textContent = preset.name || id;
            item.appendChild(label);

            this.presetDropdownContent!.appendChild(item);
          });
        }
      }

      private loadPreset(id: string) {
        const allPresets = getAllPresets();
        const preset = allPresets[id];
        if (!preset) return;

        this.currentPresetId = id;
        this.isCustomPreset = !!preset.isCustom;

        // Deep clone styles
        this.workingStyles = JSON.parse(JSON.stringify(preset.styles));
        this.originalStyles = JSON.parse(JSON.stringify(preset.styles));

        // Update dropdown label
        if (this.presetLabel) {
          this.presetLabel.textContent = preset.name || id;
        }

        // Update trigger swatches
        this.updatePresetSwatches();

        // Update delete button state
        if (this.deletePresetBtn) {
          (this.deletePresetBtn as HTMLButtonElement).disabled =
            !this.isCustomPreset;
        }

        // Update color inputs
        this.updateColorInputs();

        // Apply theme live
        this.applyLivePreview();

        // Also update global preset
        setStoredPreset(id);
      }

      private updatePresetSwatches() {
        const styles = this.workingStyles[this.currentMode];
        if (this.presetSwatchPrimary) {
          this.presetSwatchPrimary.style.background = styles.primary || "";
        }
        if (this.presetSwatchAccent) {
          this.presetSwatchAccent.style.background = styles.accent || "";
        }
      }

      private updateColorInputs() {
        const styles = this.workingStyles[this.currentMode];

        this.querySelectorAll<HTMLElement>("color-input").forEach((input) => {
          const token = input.dataset.token;
          if (token && styles[token as keyof typeof styles]) {
            (input as any).setColor?.(
              styles[token as keyof typeof styles] as string,
            );
          }
        });
      }

      private updateColor(token: string, value: string) {
        this.workingStyles[this.currentMode][token as keyof ThemeStyleProps] =
          value;
        this.applyLivePreview();

        // Update swatches if primary or accent changed
        if (token === "primary" || token === "accent") {
          this.updatePresetSwatches();
        }
      }

      private applyLivePreview() {
        applyThemeToElement(
          { styles: this.workingStyles, currentMode: this.currentMode },
          document.documentElement,
        );
      }

      private switchMode(mode: "light" | "dark", fromExternal = false) {
        this.currentMode = mode;
        this.updateModeTabsUI();
        this.updateColorInputs();
        this.updatePresetSwatches();

        // Only update the global theme if this isn't from an external change
        if (!fromExternal) {
          // Update localStorage (same key as ThemeSwitcher)
          localStorage.setItem("starlight-theme", mode);

          // Update document state
          document.documentElement.dataset.theme = mode;
          document.documentElement.dataset.themeChoice = mode;
          document.documentElement.classList.toggle("dark", mode === "dark");

          // Dispatch event for other components to react
          window.dispatchEvent(
            new CustomEvent("theme-toggle-changed", {
              detail: { theme: mode },
            }),
          );

          // Update the global ThemeSwitcher tabs
          document
            .querySelector<HTMLDivElement>("#theme-tabs")
            ?.dispatchEvent(
              new CustomEvent("tabs:select", { detail: { value: mode } }),
            );
        }

        this.applyLivePreview();
      }

      private updateModeTabsUI() {
        this.modeTabs?.querySelectorAll(".mode-tab").forEach((tab) => {
          const isActive =
            (tab as HTMLElement).dataset.mode === this.currentMode;
          tab.classList.toggle("active", isActive);
        });

        // Update the Tabs component's visual state
        const tabsEl = this.modeTabs?.querySelector('[data-slot="tabs"]');
        tabsEl?.dispatchEvent(
          new CustomEvent("tabs:select", {
            detail: { value: this.currentMode },
          }),
        );
      }

      private startNewPreset() {
        this.isCreatingNew = true;
        if (this.presetNameInput) {
          this.presetNameInput.style.display = "block";
          this.presetNameInput.value = `${this.presetLabel?.textContent || "Custom"} Copy`;
          this.presetNameInput.focus();
          this.presetNameInput.select();
        }
      }

      private confirmNewPreset() {
        if (!this.presetNameInput) return;

        const name = this.presetNameInput.value.trim();
        if (!name) {
          this.cancelNewPreset();
          return;
        }

        const newPreset: CustomPreset = {
          id: generatePresetId(),
          name,
          label: name,
          createdAt: new Date().toISOString(),
          modifiedAt: new Date().toISOString(),
          source: "SAVED",
          styles: JSON.parse(JSON.stringify(this.workingStyles)),
        };

        saveCustomPreset(newPreset);
        this.cancelNewPreset();
        this.loadPreset(newPreset.id);
        this.showToast(`Created preset "${name}"`);
      }

      private cancelNewPreset() {
        this.isCreatingNew = false;
        if (this.presetNameInput) {
          this.presetNameInput.style.display = "none";
          this.presetNameInput.value = "";
        }
      }

      private deleteCurrentPreset() {
        if (!this.isCustomPreset || !this.currentPresetId) return;

        const allPresets = getAllPresets();
        const preset = allPresets[this.currentPresetId];
        if (!preset) return;

        if (confirm(`Delete preset "${preset.name}"?`)) {
          deleteCustomPreset(this.currentPresetId);
          this.showToast(`Deleted preset "${preset.name}"`);

          // Load first built-in preset
          this.loadPreset(Object.keys(defaultPresets)[0]);
        }
      }

      private resetToOriginal() {
        this.workingStyles = JSON.parse(JSON.stringify(this.originalStyles));
        this.updateColorInputs();
        this.applyLivePreview();
        this.showToast("Reset to original");
      }

      private savePreset() {
        if (this.isCustomPreset) {
          // Update existing custom preset
          const customPresets = getCustomPresets();
          const existing = customPresets[this.currentPresetId];
          if (existing) {
            const updated: CustomPreset = {
              ...existing,
              styles: JSON.parse(JSON.stringify(this.workingStyles)),
              modifiedAt: new Date().toISOString(),
            };
            saveCustomPreset(updated);
            this.originalStyles = JSON.parse(
              JSON.stringify(this.workingStyles),
            );
            this.showToast(`Saved "${existing.name}"`);
          }
        } else {
          // Create new custom preset from built-in
          this.startNewPreset();
        }
      }

      private getImportTextarea(): HTMLTextAreaElement | null {
        // The dialog portal might be moved to document.body, so search there
        // Get the last matching element in case of duplicates after View Transitions
        const all = document.querySelectorAll("#import-css-textarea");
        return (all[all.length - 1] as HTMLTextAreaElement) || null;
      }

      private getImportDialog(): Element | null {
        const all = document.querySelectorAll("#import-dialog");
        return all[all.length - 1] || null;
      }

      private getAIPromptTextarea(): HTMLTextAreaElement | null {
        // The dialog portal might be moved to document.body, so search there
        // Get the last matching element in case of duplicates after View Transitions
        const all = document.querySelectorAll("#ai-prompt-textarea");
        return (all[all.length - 1] as HTMLTextAreaElement) || null;
      }

      private getAIDialog(): Element | null {
        const all = document.querySelectorAll("#ai-generate-dialog");
        return all[all.length - 1] || null;
      }

      private getExportCodeJson(): HTMLElement | null {
        const all = document.querySelectorAll("#export-code-json");
        return (all[all.length - 1] as HTMLElement) || null;
      }

      private getExportCodeCss(): HTMLElement | null {
        const all = document.querySelectorAll("#export-code-css");
        return (all[all.length - 1] as HTMLElement) || null;
      }

      private getExportJsonDialog(): Element | null {
        const all = document.querySelectorAll("#export-json-dialog");
        return all[all.length - 1] || null;
      }

      private getExportFormatSelect(): HTMLSelectElement | null {
        const all = document.querySelectorAll("#export-format-select");
        return (all[all.length - 1] as HTMLSelectElement) || null;
      }

      private getExportTypeTabs(): HTMLElement | null {
        const all = document.querySelectorAll("#export-type-tabs");
        return (all[all.length - 1] as HTMLElement) || null;
      }

      private currentExportType: "json" | "css" = "json";

      private convertColor(
        color: string,
        format: "oklch" | "hsl" | "rgb" | "hex",
      ): string {
        if (!color) return color;

        // Parse OKLCH color: oklch(L C H) or oklch(L C H / A)
        const oklchMatch = color.match(
          /oklch\(\s*([\d.]+)\s+([\d.]+)\s+([\d.]+)(?:\s*\/\s*([\d.]+))?\s*\)/i,
        );

        if (!oklchMatch) {
          // If not OKLCH, return as-is
          return color;
        }

        const L = parseFloat(oklchMatch[1]);
        const C = parseFloat(oklchMatch[2]);
        const H = parseFloat(oklchMatch[3]);
        const alpha = oklchMatch[4] ? parseFloat(oklchMatch[4]) : 1;

        if (format === "oklch") {
          return color; // Already OKLCH
        }

        // Convert OKLCH to sRGB
        // Using simplified conversion (approximate)
        const hRad = (H * Math.PI) / 180;
        const a = C * Math.cos(hRad);
        const b = C * Math.sin(hRad);

        // OKLCH to OKLab
        const l_ = L + 0.3963377774 * a + 0.2158037573 * b;
        const m_ = L - 0.1055613458 * a - 0.0638541728 * b;
        const s_ = L - 0.0894841775 * a - 1.291485548 * b;

        const l = l_ * l_ * l_;
        const m = m_ * m_ * m_;
        const s = s_ * s_ * s_;

        // OKLab to linear sRGB
        let rLin = 4.0767416621 * l - 3.3077115913 * m + 0.2309699292 * s;
        let gLin = -1.2684380046 * l + 2.6097574011 * m - 0.3413193965 * s;
        let bLin = -0.0041960863 * l - 0.7034186147 * m + 1.707614701 * s;

        // Linear to sRGB
        const toSrgb = (c: number) => {
          c = Math.max(0, Math.min(1, c));
          return c <= 0.0031308
            ? 12.92 * c
            : 1.055 * Math.pow(c, 1 / 2.4) - 0.055;
        };

        let r = Math.round(toSrgb(rLin) * 255);
        let g = Math.round(toSrgb(gLin) * 255);
        let bl = Math.round(toSrgb(bLin) * 255);

        // Clamp values
        r = Math.max(0, Math.min(255, r));
        g = Math.max(0, Math.min(255, g));
        bl = Math.max(0, Math.min(255, bl));

        if (format === "hex") {
          const toHex = (n: number) => n.toString(16).padStart(2, "0");
          if (alpha < 1) {
            return `#${toHex(r)}${toHex(g)}${toHex(bl)}${toHex(Math.round(alpha * 255))}`;
          }
          return `#${toHex(r)}${toHex(g)}${toHex(bl)}`;
        }

        if (format === "rgb") {
          if (alpha < 1) {
            return `rgb(${r} ${g} ${bl} / ${alpha})`;
          }
          return `rgb(${r} ${g} ${bl})`;
        }

        if (format === "hsl") {
          // RGB to HSL
          const rNorm = r / 255;
          const gNorm = g / 255;
          const bNorm = bl / 255;

          const max = Math.max(rNorm, gNorm, bNorm);
          const min = Math.min(rNorm, gNorm, bNorm);
          const lum = (max + min) / 2;

          let hue = 0;
          let sat = 0;

          if (max !== min) {
            const d = max - min;
            sat = lum > 0.5 ? d / (2 - max - min) : d / (max + min);

            switch (max) {
              case rNorm:
                hue = ((gNorm - bNorm) / d + (gNorm < bNorm ? 6 : 0)) / 6;
                break;
              case gNorm:
                hue = ((bNorm - rNorm) / d + 2) / 6;
                break;
              case bNorm:
                hue = ((rNorm - gNorm) / d + 4) / 6;
                break;
            }
          }

          const hDeg = Math.round(hue * 360);
          const sPct = Math.round(sat * 100);
          const lPct = Math.round(lum * 100);

          if (alpha < 1) {
            return `hsl(${hDeg} ${sPct}% ${lPct}% / ${alpha})`;
          }
          return `hsl(${hDeg} ${sPct}% ${lPct}%)`;
        }

        return color;
      }

      private convertStyleColors(
        styles: { light: Record<string, string>; dark: Record<string, string> },
        format: "oklch" | "hsl" | "rgb" | "hex",
      ): { light: Record<string, string>; dark: Record<string, string> } {
        const convertObj = (obj: Record<string, string>) => {
          const result: Record<string, string> = {};
          for (const [key, value] of Object.entries(obj)) {
            result[key] = this.convertColor(value, format);
          }
          return result;
        };

        return {
          light: convertObj(styles.light),
          dark: convertObj(styles.dark),
        };
      }

      public updateExportContent() {
        const select = this.getExportFormatSelect();
        const format = (select?.value || "oklch") as
          | "oklch"
          | "hsl"
          | "rgb"
          | "hex";

        const convertedStyles = this.convertStyleColors(
          this.workingStyles,
          format,
        );

        const jsonEl = this.getExportCodeJson();
        const cssEl = this.getExportCodeCss();

        // Generate JSON content
        if (jsonEl) {
          const data = {
            name: this.presetLabel?.textContent || "Theme",
            exportedAt: new Date().toISOString(),
            styles: convertedStyles,
          };
          const jsonStr = JSON.stringify(data, null, 2);
          jsonEl.textContent = jsonStr;
          // Apply Prism highlighting
          if (typeof Prism !== "undefined") {
            jsonEl.innerHTML = Prism.highlight(
              jsonStr,
              Prism.languages.json,
              "json",
            );
          }
        }

        // Generate CSS content
        if (cssEl) {
          const cssStr = this.generateCssExport(convertedStyles);
          cssEl.textContent = cssStr;
          // Apply Prism highlighting
          if (typeof Prism !== "undefined") {
            cssEl.innerHTML = Prism.highlight(
              cssStr,
              Prism.languages.css,
              "css",
            );
          }
        }
      }

      private generateCssExport(styles: {
        light: Record<string, string>;
        dark: Record<string, string>;
      }): string {
        const lines: string[] = [];
        lines.push(
          "/* Theme: " + (this.presetLabel?.textContent || "Theme") + " */",
        );
        lines.push("");

        // Light mode (root)
        lines.push(":root {");
        for (const [key, value] of Object.entries(styles.light)) {
          lines.push(`  --${key}: ${value};`);
        }
        lines.push("}");
        lines.push("");

        // Dark mode
        lines.push(".dark {");
        for (const [key, value] of Object.entries(styles.dark)) {
          lines.push(`  --${key}: ${value};`);
        }
        lines.push("}");

        return lines.join("\n");
      }

      private openExportJsonDialog() {
        // Reset format to OKLCH and type to JSON
        const select = this.getExportFormatSelect();
        if (select) select.value = "oklch";
        this.currentExportType = "json";

        // Reset tabs UI to JSON
        const tabs = this.getExportTypeTabs();
        if (tabs) {
          tabs.dispatchEvent(
            new CustomEvent("tabs:select", { detail: { value: "json" } }),
          );
        }

        // Generate initial content
        this.updateExportContent();

        // Click the hidden trigger to open the dialog
        const triggers = document.querySelectorAll(
          "#export-json-dialog-trigger",
        );
        const trigger = triggers[triggers.length - 1] as HTMLElement | null;
        trigger?.click();
      }

      public handleExportJsonCopy() {
        const codeEl =
          this.currentExportType === "json"
            ? this.getExportCodeJson()
            : this.getExportCodeCss();
        if (!codeEl) return;

        this.copyToClipboard(codeEl.textContent || "");
        this.showToast(
          this.currentExportType === "json"
            ? "JSON copied to clipboard"
            : "CSS copied to clipboard",
        );
      }

      public setExportType(type: "json" | "css") {
        this.currentExportType = type;
        // No need to re-render, tabs handle visibility
      }

      private openImportDialog() {
        // Clear the textarea
        const textarea = this.getImportTextarea();
        if (textarea) textarea.value = "";

        // Click the hidden trigger to open the dialog (get last one in case of duplicates)
        const triggers = document.querySelectorAll("#import-dialog-trigger");
        const trigger = triggers[triggers.length - 1] as HTMLElement | null;
        trigger?.click();
      }

      public handleImport() {
        const textarea = this.getImportTextarea();
        if (!textarea) {
          console.error("Import textarea not found");
          return;
        }

        const css = textarea.value.trim();
        if (!css) {
          this.showToast("Please paste some CSS to import");
          return;
        }

        try {
          const parsed = this.parseCssVariables(css);
          if (
            Object.keys(parsed.light).length === 0 &&
            Object.keys(parsed.dark).length === 0
          ) {
            this.showToast("No valid CSS variables found");
            return;
          }

          // Merge parsed values into working styles
          if (Object.keys(parsed.light).length > 0) {
            this.workingStyles.light = {
              ...this.workingStyles.light,
              ...parsed.light,
            };
          }
          if (Object.keys(parsed.dark).length > 0) {
            this.workingStyles.dark = {
              ...this.workingStyles.dark,
              ...parsed.dark,
            };
          }

          // Update the UI
          this.updateColorInputs();
          this.applyLivePreview();

          // Close the dialog
          const dialog = this.getImportDialog();
          const closeBtn = dialog?.querySelector(
            '[data-slot="dialog-close"]',
          ) as HTMLElement;
          closeBtn?.click();

          const lightCount = Object.keys(parsed.light).length;
          const darkCount = Object.keys(parsed.dark).length;
          this.showToast(
            `Imported ${lightCount} light + ${darkCount} dark variables`,
          );
        } catch (e) {
          console.error("Import error:", e);
          this.showToast("Failed to parse CSS");
        }
      }

      private parseCssVariables(css: string): {
        light: Record<string, string>;
        dark: Record<string, string>;
      } {
        const result: {
          light: Record<string, string>;
          dark: Record<string, string>;
        } = {
          light: {},
          dark: {},
        };

        // Match :root or html block for light mode
        const rootMatch =
          css.match(/:root\s*\{([^}]+)\}/s) || css.match(/html\s*\{([^}]+)\}/s);
        if (rootMatch) {
          this.extractVariables(rootMatch[1], result.light);
        }

        // Match .dark block for dark mode
        const darkMatch =
          css.match(/\.dark\s*\{([^}]+)\}/s) ||
          css.match(/html\.dark\s*\{([^}]+)\}/s) ||
          css.match(/:root\.dark\s*\{([^}]+)\}/s) ||
          css.match(/\[data-theme="dark"\]\s*\{([^}]+)\}/s);
        if (darkMatch) {
          this.extractVariables(darkMatch[1], result.dark);
        }

        return result;
      }

      private extractVariables(block: string, target: Record<string, string>) {
        // Match CSS variable declarations: --name: value;
        const varRegex = /--([a-zA-Z0-9-]+)\s*:\s*([^;]+);/g;
        let match;

        // Valid theme tokens
        const validTokens = [
          "background",
          "foreground",
          "card",
          "card-foreground",
          "popover",
          "popover-foreground",
          "primary",
          "primary-foreground",
          "secondary",
          "secondary-foreground",
          "muted",
          "muted-foreground",
          "accent",
          "accent-foreground",
          "destructive",
          "destructive-foreground",
          "border",
          "input",
          "ring",
          "chart-1",
          "chart-2",
          "chart-3",
          "chart-4",
          "chart-5",
          "sidebar",
          "sidebar-foreground",
          "sidebar-primary",
          "sidebar-primary-foreground",
          "sidebar-accent",
          "sidebar-accent-foreground",
          "sidebar-border",
          "sidebar-ring",
        ];

        while ((match = varRegex.exec(block)) !== null) {
          const name = match[1].trim();
          let value = match[2].trim();

          if (!validTokens.includes(name)) continue;

          // Convert space-separated HSL values (shadcn format) to hsl()
          // Pattern: "30 33% 98%" or "345 18% 12%" (h s% l%)
          const hslSpacePattern =
            /^(\d+(?:\.\d+)?)\s+(\d+(?:\.\d+)?)%\s+(\d+(?:\.\d+)?)%$/;
          const hslMatch = value.match(hslSpacePattern);

          if (hslMatch) {
            const [, h, s, l] = hslMatch;
            value = `hsl(${h} ${s}% ${l}%)`;
          }

          target[name] = value;
        }
      }

      private copyToClipboard(text: string) {
        navigator.clipboard.writeText(text).catch(() => {
          // Fallback
          const textarea = document.createElement("textarea");
          textarea.value = text;
          document.body.appendChild(textarea);
          textarea.select();
          document.execCommand("copy");
          document.body.removeChild(textarea);
        });
      }

      private showToast(message: string) {
        const existing = document.querySelector(".theme-editor-toast");
        existing?.remove();

        const toast = document.createElement("div");
        toast.className = "theme-editor-toast";
        toast.textContent = message;
        document.body.appendChild(toast);

        setTimeout(() => toast.remove(), 2500);
      }

      private handleExternalPresetChange(e: Event) {
        const detail = (e as CustomEvent).detail;
        if (detail?.key && detail.key !== this.currentPresetId) {
          this.loadPreset(detail.key);
        }
      }

      public toggle() {
        if (this.classList.contains("open")) {
          this.close();
        } else {
          this.open();
        }
      }

      public open() {
        this.classList.add("open");
        this.loadInitialState();
      }

      public close() {
        this.classList.remove("open");
      }

      // AI Dialog methods
      private openAIDialog() {
        // Open dialog first so elements are in DOM
        const triggers = document.querySelectorAll(
          "#ai-generate-dialog-trigger",
        );
        const trigger = triggers[triggers.length - 1] as HTMLElement | null;
        trigger?.click();

        // Clear previous state after a tick (dialog needs to render)
        setTimeout(() => {
          const promptTextarea = this.getAIPromptTextarea();
          if (promptTextarea) promptTextarea.value = "";

          this.aiImages = [];
          this.updateAIImagePreview();

          // Hide status and reasoning (query globally for portaled elements)
          const allStatus = document.querySelectorAll("#ai-status");
          const allReasoning = document.querySelectorAll("#ai-reasoning");
          const allStatusIcon = document.querySelectorAll("#ai-status-icon");
          const allGenerateBtn = document.querySelectorAll(
            "#ai-generate-confirm-btn",
          );

          const status = allStatus[allStatus.length - 1] as HTMLElement | null;
          const reasoning = allReasoning[
            allReasoning.length - 1
          ] as HTMLElement | null;
          const statusIcon = allStatusIcon[
            allStatusIcon.length - 1
          ] as HTMLElement | null;
          const generateBtn = allGenerateBtn[
            allGenerateBtn.length - 1
          ] as HTMLButtonElement | null;

          if (status) status.style.display = "none";
          if (reasoning) reasoning.style.display = "none";

          // Reset icon to spinner
          if (statusIcon) {
            statusIcon.innerHTML =
              '<svg class="size-4 animate-spin" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M21 12a9 9 0 1 1-6.219-8.56"/></svg>';
          }

          // Enable generate button
          if (generateBtn) {
            generateBtn.disabled = false;
            generateBtn.innerHTML =
              '<svg class="size-4 mr-1.5" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M9.937 15.5A2 2 0 0 0 8.5 14.063l-6.135-1.582a.5.5 0 0 1 0-.962L8.5 9.936A2 2 0 0 0 9.937 8.5l1.582-6.135a.5.5 0 0 1 .963 0L14.063 8.5A2 2 0 0 0 15.5 9.937l6.135 1.581a.5.5 0 0 1 0 .964L15.5 14.063a2 2 0 0 0-1.437 1.437l-1.582 6.135a.5.5 0 0 1-.963 0z"/><path d="M20 3v4"/><path d="M22 5h-4"/><path d="M4 17v2"/><path d="M5 18H3"/></svg> Generate';
          }
        }, 0);
      }

      private setupAIImageHandlers() {
        // Use event delegation on document for the AI dialog elements since they're portaled
        if (!(window as any).__aiImageHandlersSetup) {
          (window as any).__aiImageHandlersSetup = true;

          // Drag and drop
          document.addEventListener("dragover", (e) => {
            const dropzone = (e.target as HTMLElement).closest(
              "#ai-images-dropzone",
            );
            if (dropzone) {
              e.preventDefault();
              dropzone.classList.add("dragover");
            }
          });

          document.addEventListener("dragleave", (e) => {
            const dropzone = (e.target as HTMLElement).closest(
              "#ai-images-dropzone",
            );
            if (dropzone) {
              dropzone.classList.remove("dragover");
            }
          });

          document.addEventListener("drop", (e) => {
            const dropzone = (e.target as HTMLElement).closest(
              "#ai-images-dropzone",
            );
            if (dropzone) {
              e.preventDefault();
              dropzone.classList.remove("dragover");
              const files = e.dataTransfer?.files;
              const panel = document.getElementById(
                "theme-editor-panel",
              ) as ThemeEditorPanel | null;
              if (files && panel) panel.handleAIImageFiles(files);
            }
          });

          // File input change
          document.addEventListener("change", (e) => {
            const input = e.target as HTMLInputElement;
            if (input.id === "ai-images-input" && input.files) {
              const panel = document.getElementById(
                "theme-editor-panel",
              ) as ThemeEditorPanel | null;
              if (panel) {
                panel.handleAIImageFiles(input.files);
                input.value = ""; // Reset for re-selection
              }
            }
          });
        }
      }

      public handleAIImageFiles(files: FileList) {
        const maxImages = 3;
        const validTypes = [
          "image/png",
          "image/jpeg",
          "image/jpg",
          "image/webp",
        ];

        Array.from(files).forEach((file) => {
          if (this.aiImages.length >= maxImages) {
            this.showToast(`Maximum ${maxImages} images allowed`);
            return;
          }

          if (!validTypes.includes(file.type)) {
            this.showToast("Only PNG, JPG, and WebP images are supported");
            return;
          }

          const reader = new FileReader();
          reader.onload = (e) => {
            const dataUrl = e.target?.result as string;
            // Extract base64 data (remove data:image/...;base64, prefix)
            const base64 = dataUrl.split(",")[1];
            this.aiImages.push({
              data: base64,
              mediaType: file.type,
            });
            this.updateAIImagePreview();
          };
          reader.readAsDataURL(file);
        });
      }

      private updateAIImagePreview() {
        // Find all preview containers and update the last one (in case of portaled dialogs)
        const allPreviews = document.querySelectorAll("#ai-images-preview");
        const preview = allPreviews[allPreviews.length - 1] as HTMLElement;
        if (!preview) return;

        preview.innerHTML = this.aiImages
          .map(
            (img, i) => `
          <div class="ai-image-preview" data-index="${i}">
            <img src="data:${img.mediaType};base64,${img.data}" alt="Reference ${i + 1}" />
            <button type="button" onclick="document.getElementById('theme-editor-panel')?.removeAIImage(${i})">Ã—</button>
          </div>
        `,
          )
          .join("");
      }

      public removeAIImage(index: number) {
        this.aiImages.splice(index, 1);
        this.updateAIImagePreview();
      }

      public async handleAIGenerate() {
        const promptTextarea = this.getAIPromptTextarea();
        const prompt = promptTextarea?.value.trim();

        if (!prompt) {
          this.showToast("Please enter a prompt describing your palette");
          return;
        }

        // Dialog content is portaled, so query globally for elements
        const getStatusElements = () => {
          const allStatus = document.querySelectorAll("#ai-status");
          const allStatusText = document.querySelectorAll("#ai-status-text");
          const allStatusIcon = document.querySelectorAll("#ai-status-icon");
          const allReasoning = document.querySelectorAll("#ai-reasoning");
          const allReasoningContent = document.querySelectorAll(
            "#ai-reasoning-content",
          );
          const allGenerateBtn = document.querySelectorAll(
            "#ai-generate-confirm-btn",
          );
          return {
            status: allStatus[allStatus.length - 1] as HTMLElement | null,
            statusText: allStatusText[
              allStatusText.length - 1
            ] as HTMLElement | null,
            statusIcon: allStatusIcon[
              allStatusIcon.length - 1
            ] as HTMLElement | null,
            reasoning: allReasoning[
              allReasoning.length - 1
            ] as HTMLElement | null,
            reasoningContent: allReasoningContent[
              allReasoningContent.length - 1
            ] as HTMLElement | null,
            generateBtn: allGenerateBtn[
              allGenerateBtn.length - 1
            ] as HTMLButtonElement | null,
          };
        };

        const elements = getStatusElements();
        const { status, statusText, reasoning, reasoningContent, generateBtn } =
          elements;

        // Show loading state
        if (status) {
          status.style.display = "flex";
        }
        if (statusText) {
          statusText.textContent = "Initializing...";
        }
        // Reset icon to spinner
        if (elements.statusIcon) {
          elements.statusIcon.innerHTML =
            '<svg class="size-4 animate-spin" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M21 12a9 9 0 1 1-6.219-8.56"/></svg>';
        }
        if (reasoning) reasoning.style.display = "none";
        if (generateBtn) {
          generateBtn.disabled = true;
          generateBtn.innerHTML =
            '<svg class="size-4 mr-1.5 animate-spin" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M21 12a9 9 0 1 1-6.219-8.56"/></svg> Generating...';
        }

        try {
          const response = await fetch("/api/ai/generate-palette", {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({
              prompt,
              images: this.aiImages.length > 0 ? this.aiImages : undefined,
            }),
          });

          if (!response.ok) {
            const errorData = await response.json().catch(() => ({}));
            throw new Error(errorData.error || "Failed to generate palette");
          }

          // Read SSE stream
          const reader = response.body?.getReader();
          if (!reader) {
            throw new Error("No response stream available");
          }

          const decoder = new TextDecoder();
          let buffer = "";
          let receivedPalette: any = null;
          let receivedReasoning: string | undefined;

          while (true) {
            const { done, value } = await reader.read();
            if (done) break;

            buffer += decoder.decode(value, { stream: true });

            // Process complete SSE messages
            const lines = buffer.split("\n");
            buffer = lines.pop() || ""; // Keep incomplete line in buffer

            for (const line of lines) {
              if (line.startsWith("data: ")) {
                try {
                  const event = JSON.parse(line.slice(6));

                  // Re-query elements for each update (dialog is portaled)
                  const currentElements = getStatusElements();

                  // Update UI based on event type
                  switch (event.type) {
                    case "starting":
                      if (currentElements.statusText) {
                        currentElements.statusText.textContent =
                          event.message || "Analyzing...";
                      }
                      break;
                    case "searching":
                      if (currentElements.statusText) {
                        currentElements.statusText.textContent =
                          event.message || "Searching for brand colors...";
                      }
                      break;
                    case "found_sources":
                      if (currentElements.statusText) {
                        currentElements.statusText.textContent =
                          event.message || "Found sources";
                      }
                      break;
                    case "generating":
                      if (currentElements.statusText) {
                        currentElements.statusText.textContent =
                          event.message || "Creating your palette...";
                      }
                      break;
                    case "complete":
                      receivedPalette = event.palette;
                      receivedReasoning = event.reasoning;
                      // Change icon to checkmark
                      if (currentElements.statusIcon) {
                        currentElements.statusIcon.innerHTML =
                          '<svg class="size-4 text-green-600" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M20 6 9 17l-5-5"/></svg>';
                      }
                      break;
                    case "error":
                      throw new Error(event.message || "Generation failed");
                  }
                } catch (parseError) {
                  // Skip malformed JSON lines
                  console.warn("Failed to parse SSE event:", line);
                }
              }
            }
          }

          if (!receivedPalette) {
            throw new Error("No palette received from server");
          }

          // Re-query elements for final updates
          const finalElements = getStatusElements();

          // Show reasoning if available
          if (
            receivedReasoning &&
            finalElements.reasoning &&
            finalElements.reasoningContent
          ) {
            finalElements.reasoning.style.display = "block";
            finalElements.reasoningContent.textContent = receivedReasoning;
          }

          // Apply the generated palette
          if (receivedPalette.light) {
            this.workingStyles.light = {
              ...this.workingStyles.light,
              ...receivedPalette.light,
            };
          }
          if (receivedPalette.dark) {
            this.workingStyles.dark = {
              ...this.workingStyles.dark,
              ...receivedPalette.dark,
            };
          }

          // Update UI
          this.updateColorInputs();
          this.applyLivePreview();

          // Auto-save as custom preset
          const paletteName = receivedPalette.name || "AI Generated";
          const newPreset: CustomPreset = {
            id: generatePresetId(),
            name: paletteName,
            label: paletteName,
            createdAt: new Date().toISOString(),
            modifiedAt: new Date().toISOString(),
            source: "AI",
            styles: {
              light: { ...this.workingStyles.light },
              dark: { ...this.workingStyles.dark },
            },
          };
          saveCustomPreset(newPreset);
          this.refreshPresetList();
          this.loadPreset(newPreset.id);

          // Update status
          if (finalElements.statusText)
            finalElements.statusText.textContent = `Generated "${paletteName}" palette!`;

          // Close dialog after short delay
          setTimeout(() => {
            const aiDialog = this.getAIDialog();
            const closeBtn = aiDialog?.querySelector(
              '[data-slot="dialog-close"]',
            ) as HTMLElement;
            closeBtn?.click();

            this.showToast(`Saved "${paletteName}" as custom preset`);
          }, 1500);
        } catch (error) {
          console.error("AI generation error:", error);
          const message =
            error instanceof Error ? error.message : "Generation failed";
          this.showToast(message);

          // Re-query elements for error display
          const errorElements = getStatusElements();
          if (errorElements.statusText)
            errorElements.statusText.textContent = `Error: ${message}`;
        } finally {
          // Re-query elements for button reset
          const resetElements = getStatusElements();
          if (resetElements.generateBtn) {
            resetElements.generateBtn.disabled = false;
            resetElements.generateBtn.innerHTML =
              '<svg class="size-4 mr-1.5" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M9.937 15.5A2 2 0 0 0 8.5 14.063l-6.135-1.582a.5.5 0 0 1 0-.962L8.5 9.936A2 2 0 0 0 9.937 8.5l1.582-6.135a.5.5 0 0 1 .963 0L14.063 8.5A2 2 0 0 0 15.5 9.937l6.135 1.581a.5.5 0 0 1 0 .964L15.5 14.063a2 2 0 0 0-1.437 1.437l-1.582 6.135a.5.5 0 0 1-.963 0z"/><path d="M20 3v4"/><path d="M22 5h-4"/><path d="M4 17v2"/><path d="M5 18H3"/></svg> Generate';
          }
        }
      }
    }

    // Safely register custom element
    if (!customElements.get("theme-editor-panel")) {
      customElements.define("theme-editor-panel", ThemeEditorPanel);
    }

    // Global keyboard handler (Cmd/Ctrl + e to toggle)
    if (!(window as any).__themeEditorKeyHandler) {
      (window as any).__themeEditorKeyHandler = true;
      document.addEventListener("keydown", (e) => {
        if ((e.metaKey || e.ctrlKey) && e.key === "e") {
          e.preventDefault();
          const panel = document.getElementById(
            "theme-editor-panel",
          ) as ThemeEditorPanel | null;
          if (panel && typeof panel.toggle === "function") {
            panel.toggle();
          }
        }
      });
    }

    // FAB toggle button handler
    const toggleBtn = document.getElementById("theme-editor-toggle-btn");
    if (toggleBtn && !(toggleBtn as any).__handlerAdded) {
      (toggleBtn as any).__handlerAdded = true;
      toggleBtn.addEventListener("click", () => {
        const panel = document.getElementById(
          "theme-editor-panel",
        ) as ThemeEditorPanel | null;
        if (panel && typeof panel.toggle === "function") {
          panel.toggle();
        }
      });
    }
  </script>
</theme-editor-panel>
